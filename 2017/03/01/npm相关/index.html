<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="description" content=""><meta name="keyword"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>npm相关知识</title><link rel="shortcut icon" href="/images/avatar.png" type="image/x-icon"><link href="/styles/site.css" rel="stylesheet"><meta name="generator" content="Hexo 6.3.0"></head><body><header class="container" id="header"><div class="header"><div class="header-left"><div class="avatar"><img src="/images/avatar.png"></div><div class="author"><div class="author-name"><a href="/">tianhui</a></div><div class="about-me">huizi77xl@sina.com</div></div></div><div class="header-right"><ul class="navigation"><li><a href="/archives">归档</a></li></ul></div><div class="about-me-mask"><div class="about-me-wrap"><div class="about-me__header"><div class="avatar"><img src="/images/avatar.png"></div></div><ul class="socials"><li class="social-item"><span class="label"><img src="/images/socials/github.svg" alt="https://github.com/jellyhui"></span><a href="https://github.com/jellyhui" target="_blank" title="https://github.com/jellyhui">https://github.com/jellyhui</a></li><li class="social-item"><span class="label"><img src="/images/socials/email.svg" alt="huizi77xl@sina.com"></span><span>huizi77xl@sina.com</span></li><li class="social-item"><span class="label"><img src="/images/socials/wechat.svg" alt="huizi_77"></span><span>huizi_77</span></li></ul></div></div></div></header><div class="container post"><section class="article"><div class="title">npm相关知识</div><div class="date">写于2017年03月01日</div><div class="content"><h4 id="1-简介："><a href="#1-简介：" class="headerlink" title="1. 简介："></a>1. 简介：</h4><p>  含义一：node的开放式模块登记和管理系统<br>  含义二：node默认的模块管理器，是一个命令行下的软件，用来安装和管理node模块。<br>         不需要单独安装，安装node的时候会连带一起安装，但可能不是最新版本，可以使用npm install npm@latest -g更新到最新版本。</p>
<h4 id="2-npm-init"><a href="#2-npm-init" class="headerlink" title="2.   npm init"></a>2.   npm init</h4><pre><code>--初始化生成一个新的package.json文件。可以加参数 -y 或者 -f 表示跳过向用户提问阶段，直接生成一个新的package.json文件。
</code></pre>
<h4 id="3-npm-set-xx-–-设置环境变量"><a href="#3-npm-set-xx-–-设置环境变量" class="headerlink" title="3.   npm set  xx – 设置环境变量"></a>3.   npm set  xx – 设置环境变量</h4><h4 id="4-npm-config-xx-—-设置安装目录以及安装的版本信息等"><a href="#4-npm-config-xx-—-设置安装目录以及安装的版本信息等" class="headerlink" title="4.   npm config xx — 设置安装目录以及安装的版本信息等"></a>4.   npm config xx — 设置安装目录以及安装的版本信息等</h4><h4 id="5-npm-info-xx-–-查看每个模块具体信息"><a href="#5-npm-info-xx-–-查看每个模块具体信息" class="headerlink" title="5.   npm info xx – 查看每个模块具体信息"></a>5.   npm info xx – 查看每个模块具体信息</h4><h4 id="6-npm-search-搜索词-–-搜索npm-仓库，后面的搜索词可以是字符串也可以是正则表达式"><a href="#6-npm-search-搜索词-–-搜索npm-仓库，后面的搜索词可以是字符串也可以是正则表达式" class="headerlink" title="6.   npm search 搜索词 – 搜索npm 仓库，后面的搜索词可以是字符串也可以是正则表达式"></a>6.   npm search 搜索词 – 搜索npm 仓库，后面的搜索词可以是字符串也可以是正则表达式</h4><h4 id="7-npm-list-–-以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。参数为单个模块名称或者global（全局安装的）"><a href="#7-npm-list-–-以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。参数为单个模块名称或者global（全局安装的）" class="headerlink" title="7.   npm list – 以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。参数为单个模块名称或者global（全局安装的）"></a>7.   npm list – 以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。参数为单个模块名称或者global（全局安装的）</h4><h4 id="8-npm-install-–"><a href="#8-npm-install-–" class="headerlink" title="8.   npm install –"></a>8.   npm install –</h4><pre><code>* install后可以是package name，也可以是github代码库地址；
* 全局安装 sudo npm install -g （或-global）&lt;package name&gt;；
* 全局--安装到系统目录中，各个项目都可以调用；本地安装--将一个模块下载到当前项目的node_modules子目录，只有在项目目录中才能调用；
* 安装总是会先去检查node_modules中是否已存在指定模块，如果存在，即使目前仓库里有最新版本，也不会再安装，可以加上参数 -- force强制重新安装
* 安装不同版本 在模块名后加上 @版本号（默认安装最新版本）
* 参数 --save-exact，会在package.json文件中指定安装模块的确切版本
* -save：模块名将被添加到dependencies，简化为-S
* -save-dev：模块名将被添加到devDependencies，可以简化为参数-D
</code></pre>
<h4 id="9-避免系统权限：默认安装在系统目录下（-x2F-usr-x2F-local-x2F-lib）-普通用户没有权限，需要sudo命令，因此为了方便，可以在主目录下新建配置文件-npmrc，然后在文件中将prefix变量定义到主目录下：-prefix-x3D-x2F-home-x2F-yourusername-x2F-npm，然后在主目录下新建npm子目录：mkdir-x2F-npm。此后，全局安装的模块都会安装在这个子目录中，最后将这个路径在-bash-profile文件（或者-bashrc文件）中加入PATH变量：-export-PATH-x3D-x2F-npm-x2F-bin-PATH"><a href="#9-避免系统权限：默认安装在系统目录下（-x2F-usr-x2F-local-x2F-lib）-普通用户没有权限，需要sudo命令，因此为了方便，可以在主目录下新建配置文件-npmrc，然后在文件中将prefix变量定义到主目录下：-prefix-x3D-x2F-home-x2F-yourusername-x2F-npm，然后在主目录下新建npm子目录：mkdir-x2F-npm。此后，全局安装的模块都会安装在这个子目录中，最后将这个路径在-bash-profile文件（或者-bashrc文件）中加入PATH变量：-export-PATH-x3D-x2F-npm-x2F-bin-PATH" class="headerlink" title="9. 避免系统权限：默认安装在系统目录下（&#x2F;usr&#x2F;local&#x2F;lib）,普通用户没有权限，需要sudo命令，因此为了方便，可以在主目录下新建配置文件.npmrc，然后在文件中将prefix变量定义到主目录下： prefix &#x3D; &#x2F;home&#x2F;yourusername&#x2F;npm，然后在主目录下新建npm子目录：mkdir ~&#x2F;npm。此后，全局安装的模块都会安装在这个子目录中，最后将这个路径在.bash_profile文件（或者.bashrc文件）中加入PATH变量： export PATH &#x3D; ~&#x2F;npm&#x2F;bin:$PATH."></a>9. 避免系统权限：默认安装在系统目录下（&#x2F;usr&#x2F;local&#x2F;lib）,普通用户没有权限，需要sudo命令，因此为了方便，可以在主目录下新建配置文件.npmrc，然后在文件中将prefix变量定义到主目录下： prefix &#x3D; &#x2F;home&#x2F;yourusername&#x2F;npm，然后在主目录下新建npm子目录：mkdir ~&#x2F;npm。此后，全局安装的模块都会安装在这个子目录中，最后将这个路径在.bash_profile文件（或者.bashrc文件）中加入PATH变量： export PATH &#x3D; ~&#x2F;npm&#x2F;bin:$PATH.</h4><h4 id="10-npm-update，npm-uninstall-–更新和卸载"><a href="#10-npm-update，npm-uninstall-–更新和卸载" class="headerlink" title="10. npm update，npm uninstall –更新和卸载"></a>10. npm update，npm uninstall –更新和卸载</h4><h4 id="11-npm-run–-执行脚本，在package-json的script字段，可以用于指定脚本对应命令，供npm直接调用。如下图中，可以直接使用npm-run-lint表示执行eslint，npm-run-test命令行则表示执行mocha-test-x2F-。"><a href="#11-npm-run–-执行脚本，在package-json的script字段，可以用于指定脚本对应命令，供npm直接调用。如下图中，可以直接使用npm-run-lint表示执行eslint，npm-run-test命令行则表示执行mocha-test-x2F-。" class="headerlink" title="11. npm run– 执行脚本，在package.json的script字段，可以用于指定脚本对应命令，供npm直接调用。如下图中，可以直接使用npm run lint表示执行eslint，npm run test命令行则表示执行mocha test&#x2F; 。"></a>11. npm run– 执行脚本，在package.json的script字段，可以用于指定脚本对应命令，供npm直接调用。如下图中，可以直接使用npm run lint表示执行eslint，npm run test命令行则表示执行mocha test&#x2F; 。</h4><pre><code>*   npm如果不加参数直接运行，会列出package.json中所有可执行的脚本命令。
*   npm run 会创建一个shell，执行指定的命令，并临时将node_modules/.bin加入PATH变量，这意味着本地模块可以直接运行。
* 例如npm i eslint --save-dev会产生两个结果：首先eslint会被安装到当前目录的node_modules子目录，其次，node_modules/.bin目录会生成一个符号链接node_modules/.bin/eslint，指向eslint的可执行脚本，然后就可以在package.json的script属性里边，不带路径的引用eslint这个脚本。然后在执行npm run lint时就会自动执行./node_modules/.bin/eslint . 
* 还可以自己添加参数
</code></pre>
<p>12. </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;lint&quot;: &quot;eslint .&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;mocha test/&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="13">
<li>pre-和post脚本： npm run 为每一条命令都提供了两个pre-和post-两个钩子，也就是说例如npm run lint执行时，npm会先查看有没有定义pre-和post-，如果有则会先执行 npm run prelint  然后执行npm run lint ，最后是npm run postlint。</li>
<li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dist:modules&quot;: &quot;babel ./src --out-dir ./dist-modules&quot;,</span><br><span class="line">  &quot;gh-pages&quot;: &quot;webpack&quot;,</span><br><span class="line">  &quot;gh-pages:deploy&quot;: &quot;gh-pages -d gh-pages&quot;,</span><br><span class="line">  &quot;prepublish&quot;: &quot;npm run dist:modules&quot;,</span><br><span class="line">  &quot;postpublish&quot;: &quot;npm run gh-pages &amp;&amp; npm run gh-pages:deploy&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在上图中，当执行npm run publish时，会找prepublish，运行npm run dist ： modules，也就是会去执行babel编译。</p>
</div><div class="tags"><a class="tag-link" href="/tags/js-%E6%A1%86%E6%9E%B6-%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/" rel="tag">js | 框架 | 打包工具</a></div></section></div><div class="container"><ul class="nav"><li>上一篇：<a href="/2017/04/05/node-blog/">node-blog知识整理</a></li><li>下一篇：<a href="/2017/02/26/js%E9%9D%A2%E8%AF%95%E9%A2%98/">js面试题</a></li></ul></div><div id="backToTop"><div class="back-arrow back-arrow-left"></div><div class="back-arrow back-arrow-right"></div></div><footer class="container"><div class="rights"><span>Powered by </span><a href="http://hexo.io" target="_blank">Hexo</a><span>, Theme </span><a href="https://github.com/gary-Shen/hexo-theme-bear" target="_blank">Bear</a><span>.</span></div></footer>
<script src="/script/jquery.min.js"></script>

<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/script/index.js"></script>
<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-61220413-1', 'auto');
ga('send', 'pageview');</script>
<script src="/script/post.js"></script>
</body></html>